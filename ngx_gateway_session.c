/* * Copyright (c) 2013 Zhuyx */ #include <ngx_config.h> #include <ngx_core.h> #include <ngx_event.h> #include <ngx_gateway.h> static void ngx_gateway_init_session(ngx_connection_t *c); static void ngx_gateway_set_session_socket(ngx_gateway_session_t *s); static void ngx_gateway_process_session(ngx_connection_t *c); void  ngx_gateway_init_connection(ngx_connection_t *c) { 	ngx_uint_t					i; 	ngx_gateway_port_t			*port; 	struct sockaddr				*sa; 	struct sockaddr_in			*sin; 	ngx_gateway_log_ctx_t		*ctx; 	ngx_gateway_in_addr_t		*addr; 	ngx_gateway_session_t 		*s; 	ngx_gateway_addr_conf_t 	*addr_conf; #if (NGX_HAVE_INET6) 	struct sockaddr_in6			*sin6; 	ngx_gateway_in6_addr_t		*addr6; #endif 	 	port = c->listening->servers; 	if (port->naddrs > 1) { 		if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) { 			ngx_gateway_close_connection(c); 			return; 		} 		sa = c->local_sockaddr; 		switch (sa->sa_family) { #if (NGX_HAVE_INET6) 		case AF_INET6: 			sin6 = (struct sockaddr_in6 *) sa; 			addr6 = port->addrs; 			for (i = 0; i < port->naddrs - 1; ++i) { 				if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) { 					break; 				} 			} 			addr_conf = &addr6[i].conf; 			break; #endif 		default: 			sin = (struct sockaddr_in *)sa; 			addr = port->addrs; 			for (i = 0; i < port->naddrs - 1; ++i) { 				if (addr[i].addr == sin->sin_addr.s_addr) { 					break; 				} 			} 			addr_conf = &addr[i].conf; 		} 	} else { 		switch (c->local_sockaddr->sa_family) { #if (NGX_HAVE_INET6) 		case AF_INET6: 			addr6 = port->addrs; 			addr_conf = &addr6[0].conf; 			break; #endif 		default: 			addr = port->addrs; 			addr_conf = &addr[0].conf; 			break; 		} 	}    s = ngx_pcalloc(c->pool, sizeof(ngx_gateway_session_t));    if (NULL == s) {        ngx_gateway_close_connection(c);        return;    }    if (addr_conf->default_ctx) {        s->main_conf = addr_conf->default_ctx->main_conf;        s->srv_conf = addr_conf->default_ctx->srv_conf;        s->biz_conf = addr_conf->default_ctx->biz_conf;    } else {        s->main_conf = addr_conf->ctx->main_conf;        s->srv_conf = addr_conf->ctx->srv_conf;        s->biz_conf = addr_conf->ctx->biz_conf;    }    s->addr_text = &addr_conf->addr_text;    c->data = s;    s->connection = c;    ngx_log_error(NGX_LOG_INFO, c->log, 0, "%ui client %V connected to %V",                c->number, &c->addr_text, s->addr_text);    ctx = ngx_pcalloc(c->pool, sizeof(ngx_gateway_log_ctx_t));    if (NULL == ctx) {        ngx_gateway_close_connection(c);        return;    }    ctx->client = &c->addr_text;    ctx->session = s;    c->log->connection = c->number;    c->log->handler = ngx_gateway_log_error;    c->log->data = ctx;    c->log->action = "nginx gateway module init connection";    c->log_error = NGX_ERROR_INFO;    ngx_gateway_init_session(c); } static void  ngx_gateway_init_session(ngx_connection_t *c) {    ngx_time_t                      *tp;    ngx_gateway_session_t           *s;    ngx_gateway_core_srv_conf_t     *cscf;    s = c->data;    s->signature = NGX_GATEWAY_MODULE;    s->pool = c->pool;    cscf = ngx_gateway_get_module_srv_conf(s, ngx_gateway_core_module);    if (NULL == cscf) {        ngx_gateway_finalize_session(s);        return;    }    s->ctx = ngx_pcalloc(s->pool, sizeof(void *) * ngx_gateway_max_module);    if (NULL == s->ctx) {        ngx_gateway_finalize_session(s);        return;    }    tp = ngx_timeofday();    s->start_sec = tp->sec;    s->start_msec = tp->msec;    s->bytes_read = 0;    s->bytes_write = 0;    ngx_gateway_set_session_socket(s);    ngx_gateway_process_session(c); } static void  ngx_gateway_set_session_socket(ngx_gateway_session_t *s) {    int                             keepalive;    int                             tcp_nodelay;    ngx_gateway_core_srv_conf_t     *cscf;    cscf = ngx_gateway_get_module_srv_conf(s, ngx_gateway_core_module);    if (NULL == cscf) {        ngx_gateway_finalize_session(s);        return;    }    if (cscf->so_keepalive) {        keepalive = 1;        if (setsockopt(s->connection->fd, SOL_SOCKET, SO_KEEPALIVE, (const void *) &keepalive, sizeof(int))             == -1)        {            ngx_log_error(NGX_LOG_ALERT, s->connection->log, ngx_socket_errno,                             "setsockopt(SO_KEEPALIVE) failed");        }    }    if (cscf->tcp_nodelay) {        tcp_nodelay = 1;        if (setsockopt(s->connection->fd, IPPROTO_TCP, TCP_NODELAY,                        (const void *) &tcp_nodelay, sizeof(int)) == -1)        {            ngx_log_error(NGX_LOG_ALERT, s->connnection->log, ngx_socket_errno,                         "setsockopt(TCP_NODELAY) failed");        }        s->connection->tcp_nodelay = NGX_TCP_NODELAY_SET;    } } static void ngx_gateway_process_session(ngx_connection_t *c) {    ngx_gateway_session_t               *s;    ngx_gateway_core_srv_conf_t         *cscf;    s = c->data;    cscf = ngx_tcp_get_module_srv_conf(s, ngx_gateway_core_module);    if (ngx_gateway_access_handler(s) == NGX_ERROR) {        ngx_gateway_finalize_session(s);        return;    }    cscf->protocol->init_session(s); } void  ngx_gateway_send(ngx_event_t *wev) {    ngx_int_t                   n;    ngx_connection_t            *c;    ngx_gateway_session_t       *s;    ngx_gateway_core_srv_conf_t *cscf;    c = wev->data;    s = c->data;    if (wev->timeout) {        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEOUT, "client timed out");        c->timeout = 1;        ngx_gateway_close_connection(c);        return;    }    if (s->out.len == 0) {        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {            ngx_gateway_close_connection(c);        }        return;    }    n = c->send(c, s->out.data, s->out.len);    ngx_log_debug1(NGX_LOG_DEBUG_GATEWAY, wev->log, 0, "nginx gateway send:%d", n);    if (n > 0) {        s->out.len -= n;                if (wev->timer_set) {            ngx_del_timer(wev);        }        if (s->quit) {            ngx_gateway_close_connection(c);            return;        }        return;    }    if (n == NGX_ERROR) {        ngx_gateway_close_connection(c);        return;    }    cscf = ngx_gateway_get_module_srv_conf(s, ngx_gateway_core_module);    ngx_add_timer(c->write, cscf->timeout);    if (ngx_handle_write_event(c->write, 0) != NGX_OK) {        ngx_gateway_close_connection(c);        return;      } } void ngx_gateway_session_internal_server_error(ngx_gateway_session_t *s) {    ngx_gateway_core_srv_conf_t             *cscf;    cscf = ngx_gateway_get_module_srv_conf(s, ngx_gateway_core_module);    s->out = cscf->protocol->internal_server_error;    s->quit = 1;    ngx_gateway_send(s->connection->write); } void ngx_gateway_finalize_session(ngx_gateway_session_t *s) {    ngx_connection_t        *c;    ngx_gateway_cleanup_t   *cln;    c = s->connection;    ngx_gateway_log_handler(s);    ngx_log_debug1(NGX_LOG_DEBUG_GATEWAY, c->log, 0, "close gateway session: %d", c->fd);    for (cln = s->cleanup; cln; cln = cln->next) {        if (cln->handler) {            cln->handler(cln->data);            cln->handler = NULL;        }    }    ngx_gateway_close_connection(c);    return; } void  ngx_gateway_close_connection(ngx_connection_t *c) {    ngx_pool_t          *pool;    ngx_log_debug1(NGX_LOG_DEBUG_GATEWAY, c->log, 0, "close gateway connection: %d", c->fd);#if (NGX_HAVE_STUN)    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);#endif    c->destroyed = 1;    pool = c->pool;    ngx_close_connection(c);    ngx_destroy_pool(pool); } u_char * ngx_gateway_log_error(ngx_log_t *log, u_char *buf, size_t len) {    u_char                  *p;    ngx_gateway_session_t   *s;    ngx_gateway_log_ctx_t   *ctx;    p = buf;    if (log->action) {        p = ngx_snprintf(p, len + (buf - p), "while %s", log->action);    }    ctx = log->data;    p = ngx_snprintf(p, len + (buf - p), ", client: %V", ctx->client);    s = ctx->session;    if (NULL == s) {        return p;    }    p = ngx_snprintf(p, len + (buf - p), ", server: %V", s->addr_text);    if (s->upstream) {        if (s->upstream->peer.connection) {            p = ngx_snprintf(p, len + (buf - p), ", upstream: %V", s->upstream->peer.name);        }    }    return p; } ngx_gateway_cleanup_t * ngx_gateway_cleanup_add(ngx_gateway_session_t *s, size_t size) {    ngx_gateway_cleanup_t       *cln;    cln = ngx_pcalloc(s->pool, sizeof(ngx_gateway_cleanup_t));    if (NULL == cln) {        return NULL;    }    if (size) {        cln->data = ngx_palloc(s->pool, size);        if (NULL == cln->data) {            return NULL;        }    } else {        cln->data = NULL;    }    cln->handler = NULL;    cln->next = s->cleanup;    s->cleanup = cln;    ngx_log_debug1(NGX_LOG_DEBUG_GATEWAY, s->connection->log, 0,                    "gateway cleanup add: %p", cln);    return cln; }